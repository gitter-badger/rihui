第五章 策略模式
===============

## 5.1 使用策略模式计算奖金 ##
很多公司的年终奖是根据员工的工资基数和年底绩效的情况来发放的。例如，绩效为S的人年终奖有4倍工资，绩效为A的人年终奖有3倍工资，而绩效为B的人年终奖是2倍工资。假设财务部要求我们提供一段代码，来方便计算员工的年终奖。
### 1.最初的代码 ###
``` javascript
var calculateBonus = function ( performancelevel , salary) {
    if ( performancelevel === 'S' ){
        return salary * 4;
    }

    if( performancelevel === 'A' ){
        return salary * 3;
    }

    if(performancelevel === 'B' ){
        return salary * 2;
    }
};

calculateBonus( 'B' , 20000 );           //输出40000
calculateBonus( 'S' , 6000 );            //输出24000
```
这段代码比较简单，但是存在着缺点
- calculateBonus 函数比较庞大，包含了很多 is-else 语句，这些语句需要覆盖所有的逻辑分之
- calculateBonus 函数缺乏弹性，如果增加一种新的绩效等级C，或者想把绩效S的奖金系数改为5，那么必须深入calculateBonus 函数的内部实现，违背了开闭原则。
- 算法的复用性差，如果在程序的其他地方需要重用这些计算奖金的算法，我们只能复制粘贴代码~

### 2.使用组合函数重构代码 ###
``` javascript
var performanceS = function ( salary ) {
    return salary * 4;
};

var performanceA = function ( salary ) {
    return salary * 3;
};

var performanceB = function ( salary ) {
    return salary * 2;
};

var calculateBonus = function ( performanceLeverl , salary ) {

    if(performanceLeverl === 'S' ){
        return performanceS(salary);
    }

    if(performanceLeverl === 'A' ){
        return performanceA(salary);
    }

    if(performanceLeverl === 'B' ){
        return performanceB(salary);
    }
};

calculateBonus( 'A' , 10000);           //输出30000
```
这个代码得到了一定的改善，但是非常有限，依然没有解决最重要的问题 ：calculateBonus　函数有可能越来越庞大，而且在系统变化的时候缺乏弹性
### 3.使用策略模式重构代码 ###
#### 模拟传统面向对象语言（静态语言） ####
定义绩效的计算规则的策略类
``` javascript
var performanceS = function () {};

performanceS.prototype.calculate = function ( salary ) {
    return salary * 4;
};

var performanceA = function () {};

performanceA.prototype.calculate = function ( salary ) {
    return salary * 3;
};

var performanceB = function () {};

performanceB.prototype.calculate = function ( salary ) {
    return salary * 2;
};
```
定义奖金类 `Bonus`
``` javascript
var Bonus = function () {
    this.salary = null;                 //原始工资
    this.strategy = null;               //绩效等级对应的策略对象
};

Bonus.prototype.setSalary = function ( salary ) {
    this.salary = salary;               //设置员工的原始工资
};

Bonus.prototype.setStrategy = function ( strategy ) {
    this.strategy = strategy;           //设置员工绩效等级对应的策略对象
};

/**
 * 取得奖金数额
 */
Bonus.prototype.getBouns = function () {
    return this.strategy.calculate( this.salary );          //把计算奖金的操作委托为对应的策略对象
```
创建`bonus`对象，给`bonus`对象设置一些原始数据，比如员工的原始工资数额。接下来把某个计算奖金的策略对象也传入`bonus`对象内部保存起来。当调用 `bonus.getBonus()` 来计算奖金的时候，`bonus` 对象本身并没有能力进行计算，而是把请求委托给了之前保存好的策略对象。
``` javascript
var bonus = new Bonus();

bonus.setSalary( 10000 );
bonus.setStrategy( new performanceS() );            //设置策略对象

console.log( bonus.getBouns() );                    //输出40000

bonus.setStrategy( new performanceA() );
console.log( bonus.getBouns() );                    //输出3000
```
#### javaScript 版本的策略模式 ####
在上面，我们让 `strategy` 对象从各个策略类中创建而来，这是模拟一些传统面向对象语言的实现。实际上在 javascript 语言中，函数也是对象，所以更简单和直接的做法是把 strategy 直接定义为函数：
``` js
var strategies = {
    'S' : function ( salary ) {
        return salary * 4;
    },
    'A' : function ( salary ) {
        return salary * 3;
    },
    'B' : function ( salary ) {
        return salary * 2;
    }
};

var calculateBonus = function ( level , salary ) {
    return strategies[ level ]( salary );
};

console.log( calculateBonus( 'S' , 20000 ) );           //输出80000
console.log( calculateBonus( 'A' , 10000 ) );           //输出30000
```